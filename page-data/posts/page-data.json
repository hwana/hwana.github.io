{"componentChunkName":"component---src-templates-category-template-js","path":"/posts","result":{"pageContext":{"currentCategory":"All","edges":[{"node":{"id":"dca7408e-145d-5bec-bec2-6e48c36c8cdb","excerpt":"2일차 과제를 제출하면서 강사님께 질문을 드렸다.\r\n\r\n당연히 @Override가 붙어져 있어야 한다고 생각했기 때문이다. 돌아온 대답은..!\r\n 다 계획이 있으신 거였다😎 그래서 3일차의 과제는~! 오버라이딩이 뭔가요? 여러분들이 생각하실 때, 오버라이딩을 구현하려면 @Override를 꼭 적어야 하나요? 1. 오버라이딩이란? 하위 클래스가 상위 클래스의 메소드를 재정의해서 사용하는 것 2. 오버라이딩을 구현하려면 @Override를 꼭 적어야 하나요? 개발자가 hello라는 메소드를 어떻게 사용하느냐에 따라 달라진다. Child 클래스의 hello 메소드로 사용하고 싶은 경우(오버로딩) 이 경우에는 위 코드 그대로 사용해도 문제가 없다. Parent 클래스의 hello 메소드를 사용하고 싶은 경우(오버라이딩) 매개변수, 리턴타입, 메소드명을 상위 클래스의 메소드와 동일하게 작성한다면  없이도 오버라이딩된 메소드라고 인식이 된다. 하지만 위 코드는 개발자의 실수로 매개변수가 다르…","fields":{"slug":"/spring3/"},"frontmatter":{"categories":"스진초 자바","title":"과제3) @Override 꼭 적어야 할까요?","date":"July 29, 2023"}},"next":{"fields":{"slug":"/spring2/"}},"previous":null},{"node":{"id":"526ec4d9-c8e4-5833-bb4c-7660bfe99217","excerpt":"오늘도 역시나 내 머리속에 있고 나 혼자서는 응~그치그치~ 하면서 이해할 수 있는 내용이지만, 남에게 설명하려면 입이 안 떨어지고 어버버하게되는 그런 과제였다. 그 과제가 뭐냐구요..? 인터페이스가 가지고 있는 객체 지향의 특징에는 어떤 것이 있는지 그렇게 생각하는 이유는 무엇인지 자! 오늘도 머리에 있는걸 열심히 끄집어 내보자🤯\r\n 내 머릿속에 있는 생각 객체지향의 특징에는 캡슐화, 추상화, 다형성, 상속이 있다. 인터페이스는 이 속성들 4가지를 모두 가지고 있다고 생각한다. 캡슐화 인터페이스는 상수와 추상메소드만을 가질 수 있다. 추상메소드만을 가질 수 있다는 것은 메소드의 구현을 클래스에게 위임하였다는 뜻으로, 각 기능의 정의와 구현을 분리하여 캡슐화를 한 것이다. 추상화 인터페이스는 공통된 기능을 추출해서 정의한 것이기 때문에 추상화 되었다. 다형성 인터페이스를 구현한 클래스라면, 인스턴스의 참조변수 타입을 인터페이스로 할 수있다. 상속 인터페이스도 인터페이스를 상속받을 수…","fields":{"slug":"/spring2/"},"frontmatter":{"categories":"스진초 자바","title":"과제2) 인터페이스요..?","date":"July 25, 2023"}},"next":{"fields":{"slug":"/spring1/"}},"previous":{"fields":{"slug":"/spring3/"}}},{"node":{"id":"4a83eb23-6d09-5f64-b2c0-97c6af5eb5fe","excerpt":"어제 첫 라이브 세션을 시작으로 스진초 과정이 시작되었다!\r\n프로그래밍은 외우는 것이 아니라 생각하고 이해하면서 해야한다고 말씀해주셨는데, 첫 과제부터 스진초의 정체성이 잘 나타나는거 같다. 내가 생각하는 캡슐화, 추상화, 다형성, 상속성 최근에 자바의 정석을 읽으면서 내용정리를 했기때문에 과제를 보고 ‘ㅎ..할만하군..’ 이라고 생각했다. 하지만 지금 이 글을 적는 이 순간 머리속에 있는 꺼내려고 하니까 쉽지않다. 그래도 최대한 적어봐야지..! 캡슐화 데이터의 무분별한 변경을 방지하기 위해서 접근제어자를 private으로 선언하여 외부의 접근을 막는 방식 추상화 추상 클래스를 상속받은 하위 클래스에게 메소드의 작성을 위임하는 방식 다형성 상위 클래스의 타입으로 하위 클래스의 인스턴스를 참조할 수 있도록 하는 방식 상속 공통된 속성을 모아놓은 클래스(상위 클래스)를 확장하여 새로운 클래스(하위 클래스)를 정의하는 방식 구글링으로 알아낸 캡슐화, 추상화, 다형성, 상속성 캡슐화 변수…","fields":{"slug":"/spring1/"},"frontmatter":{"categories":"스진초 자바","title":"과제1) 나만의 언어로 객체 지향의 특징 설명하기","date":"July 24, 2023"}},"next":{"fields":{"slug":"/test14/"}},"previous":{"fields":{"slug":"/spring2/"}}},{"node":{"id":"8524625a-f77c-57cb-99f4-e379684c7d8d","excerpt":"문제 내 최종코드 주어진 숫자 n을 이진수로 바꿔서 String형 배열에 넣었는데 시간초과 오류가 떴다. 이전 문제처럼 char형 배열로 변경해주었더니 통과되었다. 내 최종코드","fields":{"slug":"/test14/"},"frontmatter":{"categories":"프로그래머스","title":"다음 큰 숫자","date":"July 17, 2023"}},"next":{"fields":{"slug":"/test13/"}},"previous":{"fields":{"slug":"/spring1/"}}},{"node":{"id":"3548ad9b-907a-525e-afb2-d50d434a12c7","excerpt":"문제 내 최종코드 처음에 매개변수를 String 형 배열로 만든 후 eqauls 함수를 써서 비교를 했더니 효율성 테스트에서 실패를 했다. 다른 사람의 코드를 참고하여 char로 비교를 했더니 효율성 테스트에서 통과되었다. 내 최종코드","fields":{"slug":"/test13/"},"frontmatter":{"categories":"프로그래머스","title":"완벽한 괄호","date":"July 11, 2023"}},"next":{"fields":{"slug":"/test12/"}},"previous":{"fields":{"slug":"/test14/"}}},{"node":{"id":"9c3be92f-dda9-5117-8c3c-32473cc805cb","excerpt":"문제 내 최종코드 제일 첫 글자는 무조건 대문자이기 때문에 answer을 제일 첫글자로 초기화 해준다. for문을 돌면서 공백을 만난다면 answer을 공백을 더해준다. 공백이 아니라면 해당 글자의 앞이 공백인지 확인 후 앞 글자가 공백이면 대문자로 바꿔주고 아니라면 소문자로 바꿔준다. 다른 사람의 풀이 flag를 선언해서 공백을 판단한다. 내 최종코드 다른 사람의 풀이","fields":{"slug":"/test12/"},"frontmatter":{"categories":"프로그래머스","title":"JadenCase 문자열 만들기","date":"July 11, 2023"}},"next":{"fields":{"slug":"/test11/"}},"previous":{"fields":{"slug":"/test13/"}}},{"node":{"id":"bf3cc92f-f691-56e2-9fd4-6dcfdca33c8f","excerpt":"문제 내 최종코드 (종류별 옷의 개수 + 1) * (종류별 옷의 개수 + 1) - 1 종류별 옷의 개수에 1을 더해주는 이유는 해당 종류의 옷을 안입는 경우 다 곱해주고 -1을 빼는 이유는 모두 안입는 경우를 빼주기 위함임 내 최종코드","fields":{"slug":"/test11/"},"frontmatter":{"categories":"프로그래머스","title":"의상","date":"July 05, 2023"}},"next":{"fields":{"slug":"/test10/"}},"previous":{"fields":{"slug":"/test12/"}}},{"node":{"id":"d6c0641c-af21-5ed7-b43a-4096e1fd763c","excerpt":"문제 내 최종코드 내 최종코드","fields":{"slug":"/test10/"},"frontmatter":{"categories":"프로그래머스","title":"폰켓몬","date":"July 04, 2023"}},"next":{"fields":{"slug":"/test9/"}},"previous":{"fields":{"slug":"/test11/"}}},{"node":{"id":"5e3ba19c-6dcb-53e6-824c-92c944e94d6d","excerpt":"문제 내 최종코드 내 최종코드","fields":{"slug":"/test9/"},"frontmatter":{"categories":"프로그래머스","title":"신규 아이디 추천","date":"July 03, 2023"}},"next":{"fields":{"slug":"/test8/"}},"previous":{"fields":{"slug":"/test10/"}}},{"node":{"id":"296f1420-9ffb-5e79-8914-e61f85827bea","excerpt":"문제 내 최종코드 내 최종코드","fields":{"slug":"/test8/"},"frontmatter":{"categories":"프로그래머스","title":"개인정보 수집 유효기간","date":"June 27, 2023"}},"next":{"fields":{"slug":"/test6/"}},"previous":{"fields":{"slug":"/test9/"}}},{"node":{"id":"5fd98986-06a8-5e50-990a-10b124c82cd1","excerpt":"문제 내 최종코드 arr배열을 list로 바꿔준 뒤 delete_list에 있는 숫자들을 list에서 지워준다. ArrayList의 remove()함수는 인자로 int와 Object 형태를 받을 수 있다.  : 해당 인덱스의 값이 삭제 됨  : 리스트에서 인자로 받은 객체의 값을 찾아서 첫번째로 나오는 값을 삭제 내 최종코드","fields":{"slug":"/test6/"},"frontmatter":{"categories":"프로그래머스","title":"배열의 원소 삭제하기","date":"June 26, 2023"}},"next":{"fields":{"slug":"/test7/"}},"previous":{"fields":{"slug":"/test8/"}}},{"node":{"id":"ed161433-dd52-5da8-80d3-2406dcad8fa2","excerpt":"문제 내 최종코드 다른 사람 풀이 i와 j가 같을 경우에만 1을 넣어주면 되기 때문에 위와 같은 코드로 작성하면 for문을 한 번만 작성해도 된다. 내 최종코드 다른 사람 풀이","fields":{"slug":"/test7/"},"frontmatter":{"categories":"프로그래머스","title":"특별한 이차원 배열1","date":"June 26, 2023"}},"next":{"fields":{"slug":"/test5/"}},"previous":{"fields":{"slug":"/test6/"}}},{"node":{"id":"fb5a7d14-a539-5c45-9be3-f0a5f8faaf29","excerpt":"문제 내 최종코드 내 최종코드","fields":{"slug":"/test5/"},"frontmatter":{"categories":"프로그래머스","title":"신고 결과 받기","date":"June 25, 2023"}},"next":{"fields":{"slug":"/test4/"}},"previous":{"fields":{"slug":"/test7/"}}},{"node":{"id":"d90e4aa3-5d74-5c91-9891-2cbf54e2ccf9","excerpt":"문제 내 최종코드 다른사람 풀이 참고 후 수정코드 map을 초기화 해주면 map에 해당 문자가 있는지 없는지 판단하는 코드가 줄어들게 된다. 내 최종코드 다른사람 풀이 참고 후 수정코드","fields":{"slug":"/test4/"},"frontmatter":{"categories":"프로그래머스","title":"성격 유형 검사하기","date":"June 21, 2023"}},"next":{"fields":{"slug":"/polymorphism/"}},"previous":{"fields":{"slug":"/test5/"}}},{"node":{"id":"0fed48ca-f55b-5294-8100-88aa627fdd1e","excerpt":"다형성 상위 클래스 타입의 참조변수로 하위 클래스의 인스턴스를 참조할 수 있도록 하는 것 두 클래스가 상속관계에 있을 때 상위 클래스 타입의 참조변수로 하위 클래스의 인스턴스를 참조하도록 할 수 있다.  참조변수 t로는 Tv클래스의 멤버들만 사용할 수 있다. 참조변수의 타입이 참조변수가 참조하고 있는 인스턴스에서 사용할 수 있는 멤버의 갯수를 결정한다. 참조변수와 인스턴스의 연결 메소드의 경우 실제 인스턴스의 메소드가 호출되지만 멤버변수의 경우 참조변수 타입에 따라 달라진다. 참조변수의 타입에 따라 결과가 달라지는 경우는 상위 클래스의 멤버변수와 같은 이름의 멤버변수를 하위클래스에 중복해서 정의한 경우 뿐이다. 메소드인 method()의 경우 참조변수의 타입에 관계없이 항상 실제 인스턴스 타입인 Child 클래스에 정의된 메소드가 호출되지만, 인스턴스변수인 x의 경우 참조변수 타입에 따라서 달라진다. 해당 예시는 Child 클래스에 아무런 멤버도 정의되어 있지 않기 때문에 참조변수…","fields":{"slug":"/polymorphism/"},"frontmatter":{"categories":"자바 자바의정석","title":"다형성","date":"June 20, 2023"}},"next":{"fields":{"slug":"/test3/"}},"previous":{"fields":{"slug":"/test4/"}}},{"node":{"id":"c361c992-4fa3-5311-b61d-9346c71c9307","excerpt":"문제 문제풀이 흐름 대기실의 모든 응시자 위치에 대해 반복 \r\n1-1. 좌표의 상하좌우 중 빈 테이블이 있는 방향 찾기\r\n1-2. 빈 테이블과 인접한 위치 중 응시자가 있는지 찾기 <- 거리두기를 지키지 않은 것 1의 경우를 찾지 못하면 거리두기를 지킨 것 풀이 dx, dy로 방향을 정하는 방법 \r\ndx, dy는 각각 x의 변화량, y의 변화량을 뜻한다. \r\n변화량이란 특정 방향으로 이동할 때 해당 좌표 값이 어떻게 변화하는지를 의미한다. \r\ndx, dy는 상하좌우 네 방향에 따라서 아래와 같은 값을 가진다.   상 하 좌 우 dx 0 0 -1 1 dy -1 1 0 0 맨해튼 거리  맨해튼 거리2에 도달하려면 맨해튼 거리1(상하좌우)을 거쳐야함 맨해튼 거리1이 파티션으로 막혀있다면, 맨해튼 거리2에 응시자가 있어도 거리두기 조건을 만족함 위쪽 방향의 좌표가 파티션으로 막혀있다면 위쪽 방향의 맨해튼 거리2는 더이상 추가적인 검사를 하지 않아도 되는것 처럼 보임(파란색 화살표 방향으로…","fields":{"slug":"/test3/"},"frontmatter":{"categories":"프로그래머스","title":"거리두기 확인하기","date":"June 19, 2023"}},"next":{"fields":{"slug":"/modifier/"}},"previous":{"fields":{"slug":"/polymorphism/"}}},{"node":{"id":"2f07ca54-0c65-5391-b55a-7bb6330f7ca2","excerpt":"클래스, 변수, 메소드의 선언부에 함께 사용되어 부가적인 의미를 부여한다. 제어자는 접근 제어자와 그 외 제어자로 나눌 수 있는데, 접근 제어자는 선언부에 하나만 쓸 수 있으며, 그 외 제어자는 조합하여 사용이 가능하다. static - 클래스의, 공통적인 static이 사용될 수 있는 곳 : 멤버변수, 메소드, 초기화 블럭 멤버변수에 static이 붙는다면 모든 인스턴스에 공통적으로 사용되는 클래스 변수며, 인스턴스를 생성하지 않고도 사용이 가능하다. 클래스가 메모리에 로드될 때 생성된다. 메소드에 static이 붙는다면? 인스턴스를 생성하지 않고도 사용 가능한 클래스 메소드가 된다. 클래스 메소드 내에서는 인스턴스 멤버들을 사용할 수 없다. final - 마지막의, 변경될 수 없는 final이 사용될 수 있는 곳 : 클래스, 메소드, 멤버변수, 지역변수 클래스에 final이 붙는다면 확장될 수 없다. 즉 다른 클래스의 조상이 될수 없고 상속 구조에서 제일 마지막 클래스이다. 메…","fields":{"slug":"/modifier/"},"frontmatter":{"categories":"자바 자바의정석","title":"제어자","date":"June 13, 2023"}},"next":{"fields":{"slug":"/test2/"}},"previous":{"fields":{"slug":"/test3/"}}},{"node":{"id":"91e3853e-fa1b-55ef-8c25-e73b500bce1e","excerpt":"문제 문제풀이 흐름 n*n 2차원 배열 선언하기 숫자를 채울 현재의 위치를 0,0 으로 설정 방향에 따라 이동할 수 없을때까지 반복하면서 숫자 채우기 \r\n3-1. 아래로 이동 \r\n3-2. 오른쪽으로 이동 \r\n3-3. 왼쪽 위로 이동  채워진 숫자를 차례대로 1차원 배열에 옮겨서 반환하기 풀이 dx, dy로 방향을 정하는 방법 \r\ndx, dy는 각각 x의 변화량, y의 변화량을 뜻한다. \r\n변화량이란 특정 방향으로 이동할 때 해당 좌표 값이 어떻게 변화하는지를 의미한다. \r\ndx, dy는 상하좌우 네 방향에 따라서 아래와 같은 값을 가진다.   상 하 좌 우 dx 0 0 -1 1 dy -1 1 0 0 n*n 2차원 배열 선언하기 숫자를 채울 현재 위치를 0,0 으로 설정 방향에 따라 이동할 수 없을 때까지 반복하면서 숫자 채우기 채워진 숫자를 차례대로 1차원 배열에 옮겨서 반환하기 변수 v에는 채워넣은 숫자 마지막 + 1 숫자가 들어있으므로 v-1이 채워 넣은 숫자의 개수가 된다. …","fields":{"slug":"/test2/"},"frontmatter":{"categories":"프로그래머스","title":"삼각 달팽이","date":"June 13, 2023"}},"next":{"fields":{"slug":"/extends/"}},"previous":{"fields":{"slug":"/modifier/"}}},{"node":{"id":"cef2893f-623a-5a05-a1aa-d47e6f9a4500","excerpt":"상속 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것 상속을 받는다는 것은 상위 클래스를 확장(extends)한다는 의미로 해석된다. 하위 클래스는 상위클래스의 생성자, 초기화 블럭을 제외한 모든 멤버를 모두 상속받는다. 상위 클래스가 변경되면 모든 하위 클래스는 자동으로 영향을 받지만, 하위 클래스가 변경되는 것은 상위 클래스에 아무런 영향이 없다. 포함관계 상속 이외에도 클래스를 재사용하는 다른 방법, 한 클래스의 멤버변수로 다른 클래스 타입의 참조 변수를 선언하는 것 단일상속 자바에서는 단일 상속만 허용한다. Object 클래스 Object 클래스는 모든 클래스의 상위 클래스이다. 다른 클래스로부터 상속 받지 않는 모든 클래스들은 자동으로 Object 클래스를 상속받는다. 오버라이딩 상위 클래스로부터 상속받은 메소드의 내용을 변경하는 것, 상속받은 메소드를 그대로 사용하기도 하지만 필요에 따라 변경을 해야하는 경우 상위 클래스의 메소드를 오버라이딩 한다. 오버라이딩의 …","fields":{"slug":"/extends/"},"frontmatter":{"categories":"자바 자바의정석","title":"상속","date":"June 03, 2023"}},"next":{"fields":{"slug":"/test1/"}},"previous":{"fields":{"slug":"/test2/"}}},{"node":{"id":"2311868e-e9dd-57aa-946c-ba338f5f57e7","excerpt":"문제 문제풀이 흐름 모든 직선 쌍에 대해서 반복을 진행한다. \r\n1-1. 교점 좌표를 구해서 정수 좌표만 저장하기  1의 결과에 대해 x, y 좌표의 최댓값, 최솟값 구하기 2의 결과로 2차원 배열의 크기를 결정하고 배열에 별 표시 문자열 배열로 반환 풀이 좌표를 나타내는 클래스 작성 final 사용 이유 ? 데이터를 나타내는 클래스이므로 불변성을 갖게 하기 위해서 생성자로 초기화 하도록 함 long으로 표현해야지 오버플로우가 발생하지 않음 모든 직선 쌍에 대해 반복 진행 교점 좌표 구하는 메소드 교점 좌표 구해서 정수만 리스트에 저장하기 저장된 정수 중 최댓값, 최솟값 구하기  : Long 범위 내에서 표현할 수 있는 가장 큰 숫자 값으로 초기화 구한 최솟값, 최댓값을 이용해서 2차원 배열의 크기 결정 좌표를 표현할 수 있는 최소 크기의 2차원 배열을 만들어서 ’.’ 으로 채워준다. 2차원 배열에 좌표 찍기 2차원 배열에서 (0,0)은 실제 좌표의 (0,0)이 아니므로 좌표를 변…","fields":{"slug":"/test1/"},"frontmatter":{"categories":"프로그래머스","title":"교점에 별 만들기","date":"June 03, 2023"}},"next":{"fields":{"slug":"/constructor/"}},"previous":{"fields":{"slug":"/extends/"}}},{"node":{"id":"a1f0bb92-65e0-5372-b992-34495702c71b","excerpt":"인스턴스가 생성될 때 호출되는 인스턴스 초기화 메소드 생성자의 조건 생성자의 이름은 클래스 이름과 같아야 한다. 생성자는 리턴값이 없다 생성자의 정의 생성자도 오버로딩이 가능하므로 하나의 클래스의 여러개의 생성자가 존재할 수 있다.  연산자 new에 의해서 메모리에 Card 클래스의 인스턴스가 생성된다. 생성자 Card()가 호출되어 수행된다. 인스턴스를 생성할 때 반드시 클래스 내에 정의된 생성자 중 하나를 선택하여 지정해주어야 한다. 기본생성자 컴파일할 때 클래스에 생성자가 하나도 정의되어 있지 않은 경우 컴파일러는 자동으로 기본 생성자를 추가하여 컴파일한다. 컴파일러가 자동 추가해주는 기본생성자는 매개변수와 내용이 없다.  매개변수가 있는 생성자 매개변수가 있는 생성자를 사용한다면 인스턴스를 생성하는 동시에 원하는 값으로 초기화 할 수 있다. 생성자에서 다른 생성자 호출하기 조건 생성자의 이름으로 클래스이름 대신 this를 사용한다. 반드시 첫 줄에서만 호출이 가능하다. 기본…","fields":{"slug":"/constructor/"},"frontmatter":{"categories":"자바 자바의정석","title":"생성자","date":"May 29, 2023"}},"next":{"fields":{"slug":"/class-instance/"}},"previous":{"fields":{"slug":"/test1/"}}},{"node":{"id":"08257061-5102-5c08-81e5-ec0e1d5533e8","excerpt":"클래스 클래스란 객체를 정의해 놓은 것이며, 객체를 생성하는데 사용된다.\r\n클래스를 잘 만들어 놓으면 객체를 생성할 때마다 고민을 할 필요가 없으며, 만들어 놓은 클래스로부터 객체를 생성해서 사용하기만 하면 된다. 우리는 JDK에서 제공하는 클래스들을 이용해서 쉽게 프로그램을 작성할 수 있다. 클래스의 또 다른 정의 데이터와 함수의 결합\r\n함수와 데이터는 관계가 깊기 때문에 자바에서는 변수와 함수를 하나의 클래스에 정의하여 관계가 깊은 변수와 함수를 함께 다룰 수 있게했다. 사용자 정의 타입\r\n사용자 정의 타입은 사용자가 기능 동작을 위한 데이터와 함수를 묶어서 정의하는 것이다. 객체 객체는 클래스의 정의된 내용대로 메모리에 생성된 것이다.\r\n클래스로부터 객체를 만드는 것을 클래스의 인스턴스화라고 하며, 어떤 클래스로부터 만들어진 객체를 그 클래스의 인스턴스라고 한다.\r\n객체는 포괄적인 의미를 가지고 있다면, 인스턴스는 객체보다 구체적인 의미인 어떤 클래스로부터 만들어진 것인지를 …","fields":{"slug":"/class-instance/"},"frontmatter":{"categories":"자바 자바의정석","title":"클래스, 메소드, 변수, 인스턴스, 객체","date":"May 27, 2023"}},"next":{"fields":{"slug":"/recursive-call/"}},"previous":{"fields":{"slug":"/constructor/"}}},{"node":{"id":"8a3e4e0a-9551-542d-a053-6cf939cbb8f1","excerpt":"메소드 내부에서 메소드 자신을 다시 호출하는 것 어떻게 메소드가 자기 자신을 호출할 수 있는걸까? 메소드 입장에서는 자기 자신을 호출하는 것과 다른 메소드를 호출하는 것은 차이가 없다. ‘메소드 호출’ 이라는 것이 특정 위치에 저장되어 있는 명령들을 수행하는 것일 뿐이기 때문 호출된 메소드는 원래의 값이 아닌 복사된 값으로 작업하기 때문에 호출한 메소드와 관계없이 독립적인 작업 수행이 가능하다 :  재귀호출과 반복문 재귀호출은 반복문과 유사한 점이 많으며, 대부분의 재귀호출은 반복문으로 작성하는것이 가능하다.\r\n어떤 작업을 반복적으로 처리해야한다면, 먼저 반복문으로 작성해보고 너무 복잡하다면 재귀호출로 간단하게 할 수 없는지 고민해봐야한다.\r\n반복문보다 재귀호출이 비효율적이므로 재귀호출에 드는 비용보다 재귀호출의 간결함이 주는 이득이 충분히 큰 경우에만 사용해야한다. 대표적인 재귀호출 : 팩토리얼 팩토리얼은 한 숫자가 1이 될 때까지 1씩 감소시켜가면서 계속해서 곱해 나가는 것  …","fields":{"slug":"/recursive-call/"},"frontmatter":{"categories":"자바 자바의정석","title":"재귀호출","date":"May 27, 2023"}},"next":{"fields":{"slug":"/basic-reference-parameter/"}},"previous":{"fields":{"slug":"/class-instance/"}}},{"node":{"id":"e4d51ea6-02b5-5a40-9cd7-efd3dd8c07e2","excerpt":"매개변수의 타입이 기본형일 때는 값이 복사되어서 변수의 값을 읽는 것만 가능하다.\r\n참조형일 때는 인스턴스의 주소가 복사되어서 변수의 값을 읽고 변경할 수 있다. 기본형 매개변수 호출한 메소드에 기본형 매개변수가 선언되어 있는 경우 인자(d.x)의 값을 복사하여 넘겨준 것 호출한 메소드에서 값을 1000으로 변경하더라도 호출한 메소드의 매개변수 값만 변경 될 뿐, 인자로 넘겨준 변수는 영향을 받지 않는다.\r\n 참조형 매개변수 호출된 메소드에 참조형 매개변수가 선언되어 있는 경우 값이 저장된 주소를 호출된 메소드에 넘겨준다. 호출된 메소드의 매개변수가 넘겨받은 인자와 같은 주소값을 가리키고 있기 때문에 호출된 메소드에서 값을 변경하게되면 그 주소값을 가지고 있는 변수의 값이 변경된다.\r\n 참조형 반환타입 copy메소드에서 생성한 객체를 main메소드에서 사용하려면 copy메소드 내에서 생성한 객체의 주소를 반환해주어야 한다. 그렇지 않으면 copy메소드가 종료되면서 생성한 객체의 참…","fields":{"slug":"/basic-reference-parameter/"},"frontmatter":{"categories":"자바 자바의정석","title":"기본형 매개변수와 참조형 매개변수 / 참조형 반환타입","date":"May 24, 2023"}},"next":null,"previous":{"fields":{"slug":"/recursive-call/"}}}],"categories":["All","스진초","자바","프로그래머스","자바의정석"]}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}