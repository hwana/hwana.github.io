{"componentChunkName":"component---src-templates-category-template-js","path":"/posts/자바","result":{"pageContext":{"currentCategory":"자바","categories":["All","TIL","내일배움캠프","회고","자바","스진초","프로그래머스","자바의정석"],"edges":[{"node":{"id":"2990b3c3-2c07-518c-9ff1-a99b8d43443c","excerpt":"모던 자바 인 액션을 읽던 도중 아래와 같은 코드를 보게 되었다. 디렉토리에 숨겨진 파일을 필터링하는 코드이다. 한 눈에 들어오지 않아서 인텔리제이를 켜고 하나하나 입력해봤다. new FileFilter 부분을 타이핑하자 자동완성이 되었다. 완성된 코드는 평소에 객체 생성할 때 보던 코드와 다른 모습이였다. FileFilter가 무엇인지 알아내기 위해서 내부로 들어가보았다. 인터페이스였다. 내가 아는 인터페이스는 new 키워드로 객체 생성이 불가능한데..? 뭐지? 인터페이스도 익명 객체로 객체 생성이 가능하다. 익명 객체란 말 그대로 이름이 없는 객체이다. 이름이 없기 때문에 부를 수도 없다. 그렇기 때문에 생성과 동시에 한번만 사용되고 사라진다. 일반적으로 생성한 후에 다른 메소드의 파라미터로 넘겨줄 때 사용한다. 인터페이스도 익명 객체를 생성함과 동시에 추상메소드를 구현한다면 (익명)객체로 만들 수 있다. 자바8에서 추가된 기능으로 더 이상 위와 같이 구현하지 않고, 메소드를 …","fields":{"slug":"/java/java-interface-noname-instance/"},"frontmatter":{"categories":"자바","title":"인터페이스는 객체 생성이 불가능할까?","date":"October 26, 2023"}},"next":{"fields":{"slug":"/naebaecamp/today-i-learned/2023/10/20231026/"}},"previous":{"fields":{"slug":"/naebaecamp/today-i-learned/2023/10/20231027/"}}},{"node":{"id":"db7b75ca-469b-5605-a548-69cedd25812c","excerpt":"개요 자바는 실행 시 발생할 수 있는 프로그램의 오류(런타임 에러)를 에러와 예외 두가지로 구분하였다. 에러 : 프로그램 코드에 의해서 수습될 수 없는 심각한 오류 예외 : 프로그램 코드에 의해서 수습될 수 있는 오류 에러는 프로그램이 비정상적으로 종료되는걸로 끝나지만, 예외는 적절한 코드를 미리 작성해놓음으로써 프로그램의 비정상적인 종료를 막을 수있다. 예외 클래스의 계층구조   Exception 클래스는 체크 예외(checked exception)과 언체크 예외(unchecked exception) 으로 구분된다. 체크예외(Checked Exception) Exception 클래스의 하위 클래스 중 RuntimeException 클래스를 상속받지 않는 클래스 체크예외가 발생할 수 있는 메소드를 사용할 경우 반드시 예외를 처리하는 코드를 같이 작성해야 한다. 예외처리를 해주지 않는다면 컴파일 에러가 발생한다. 위처럼 체크예외가 예외를 강제하기 때문에 예외를 누락시키지 않는다는 장…","fields":{"slug":"/java/java-exception/"},"frontmatter":{"categories":"자바","title":"예외처리","date":"October 17, 2023"}},"next":{"fields":{"slug":"/naebaecamp/today-i-learned/2023/10/20231017/"}},"previous":{"fields":{"slug":"/naebaecamp/today-i-learned/2023/10/20231018/"}}},{"node":{"id":"c9288a31-efcc-51fb-a540-036761d00c97","excerpt":"개요 컬렉션 프레임워크는 다수의 데이터를 저장하는 클래스들을 표준화한 설계이다.\r\n\r\nJDK 1.2 이전까지는 다수의 데이터를 다루기 위해서 Vector, Hashtable, Propeties와 같은 클래스를 제공했지만, 서로 각자 다른 방식으로 처리해야 했다. JDK 1.2 부터는 컬렉션 프레임워크가 등장하면서 모든 컬렉션 클래스를 표준화된 방식으로 다룰 수 있게되었다.\r\n\r\n 구성요소 \r\n이미지 출처 컬렉션 프레임워크에서는 List, Set, Map 3가지 타입의 인터페이스를 정의하였다. 그리고 공통된 부분을 다시 추출하여 Collection 인터페이스로 정의하였다. Map은 다른 두 인터페이스와 다른 형태(key, value)로 데이터를 다루기 때문에 Collection 인터페이스에 포함되지 못하였다. 인터페이스 특징 구현 클래스 List 순서가 있으며 데이터의 중복을 허용한다. ArrayList, LinkedList, Vector 등 Set 순서가 없으며 데이터의 중복을 허…","fields":{"slug":"/java/java-collections/"},"frontmatter":{"categories":"자바","title":"Collections","date":"October 16, 2023"}},"next":{"fields":{"slug":"/naebaecamp/today-i-learned/2023/10/20231016/"}},"previous":{"fields":{"slug":"/naebaecamp/today-i-learned/2023/10/20231017/"}}},{"node":{"id":"dcd65509-e518-55c6-a69c-739893c3f876","excerpt":"배열은 한번 생성하면 길이를 변경할 수 없다. 배열의 길이를 변경하기 위해서는 새로운 배열을 생성하고 데이터를 복사해야 한다. 배열을 복사하는 방법에는 얕은복사와 깊은복사가 있다. 얕은복사 얕은복사는 배열의 복사본이 원본 배열과 동일한 객체를 참조한다. 배열의 주소만 복사되고, 내부 요소들은 복사되지 않는다. 요소를 변경하게 되면 두 배열의 모든 값이 변경된다. 깊은복사 깊은복사는 원본 배열과 복사본이 서로 다른 객체를 참조한다. 하나의 배열을 변경해도 다른 배열에는 영향을 주지 않는다.","fields":{"slug":"/java/java-arrays-copy/"},"frontmatter":{"categories":"자바","title":"배열의 얕은복사와 깊은복사","date":"October 13, 2023"}},"next":{"fields":{"slug":"/java/java-arrays-class/"}},"previous":{"fields":{"slug":"/naebaecamp/today-i-learned/2023/10/20231016/"}}},{"node":{"id":"b9218cb3-1a68-5a1e-aa94-9c3a8109d363","excerpt":"자주 쓰면서 어떤 메소드가 있는지 정확하게 모르고 썼던 Arrays 클래스!\r\n이번에 확실하게 머리에 넣자! 👀 배열을 다루기 위한 다양한 메소드가 포함되어 있다. 모두 클래스 메소드 이므로 객체를 생성하지 않고 클래스명으로 접근하여 바로 생성할 수 있다.  전달받은 배열을 고정 크기의 리스트로 변환하여 반환함 실행결과 list1: [오렌지, 바나나, 체리, 딸기] : 원래 배열과 같은 주소를 바라보는 리스트\r\nlist2: [사과, 바나나, 체리, 딸기] : 새로운 객체가 생성되어 별개의 주소값을 가지는 리스트  전달받은 배열에서 특정 값의 위치를 이진 검색 알고리즘을 사용하여 검색한 후 해당 인덱스를 반환하고 찾지 못한 경우 음수 값을 반환함 이진 검색 알고리즘을 사용하므로 전달되는 배열이 미리 정렬되어 있어야 제대로 동작함 실행 결과 요소 10는 배열에서 인덱스 4에 있습니다.  전달받은 배열의 특정 길이만큼을 새로운 배열로 복사하여 반환함(깊은복사) 새로운 배열의 길이가 원본…","fields":{"slug":"/java/java-arrays-class/"},"frontmatter":{"categories":"자바","title":"Arrays class","date":"October 13, 2023"}},"next":{"fields":{"slug":"/naebaecamp/today-i-learned/2023/10/20231013/"}},"previous":{"fields":{"slug":"/java/java-arrays-copy/"}}},{"node":{"id":"2863a852-3a5b-5166-bd6a-6d4614b6437e","excerpt":"다형성은 여러가지로 표현될 수 있다. 상위 클래스 타입의 참조변수로 하위 클래스의 인스턴스를 참조할 수 있도록 하는 경우 오버라이딩과 오버로딩 두 클래스가 상속관계에 있을 때 상위 클래스 타입의 참조변수로 하위 클래스의 인스턴스를 참조하도록 할 수 있다.  참조변수 t로는 Tv클래스의 멤버들만 사용할 수 있다. 참조변수의 타입은 참조변수가 참조하고 있는 인스턴스에서 사용할 수 있는 멤버의 갯수를 결정한다. 참조변수와 인스턴스의 연결 메소드 : 참조변수 타입과 상관없이 실제 인스턴스의 메소드(오버라이딩된 메소드)가 호출 됨 멤버변수 : 상위 클래스와 하위 클래스에 동일한 변수명으로 정의되어 있기 때문에 참조변수 타입에 따라 출력값이 달라지게 된다. 상위 클래스 타입으로 선언되어 있을 경우 : 상위 클래스에 선언된 멤버변수 사용 하위 클래스 타입으로 선언되어 있을 경우 : 하위 클래스에 선언된 멤버변수 사용 매개변수의 다형성 매개변수가 Product타입의 변수라는 것은, 메소드의 매개…","fields":{"slug":"/java/java-polymorphism/"},"frontmatter":{"categories":"자바","title":"다형성","date":"June 20, 2023"}},"next":{"fields":{"slug":"/codingtest/codingtest-distance/"}},"previous":{"fields":{"slug":"/codingtest/codingtest-mbti/"}}},{"node":{"id":"551d4818-0017-5790-ac64-36c9ff204ef8","excerpt":"클래스, 변수, 메소드의 선언부에 함께 사용되어 부가적인 의미를 부여한다. 제어자는 접근 제어자와 그 외 제어자로 나눌 수 있는데, 접근 제어자는 선언부에 하나만 쓸 수 있으며, 그 외 제어자는 조합하여 사용이 가능하다. static - 클래스의, 공통적인 static이 사용될 수 있는 곳 : 멤버변수, 메소드, 초기화 블럭 멤버변수에 static이 붙는다면 모든 인스턴스에 공통적으로 사용되는 클래스 변수며, 인스턴스를 생성하지 않고도 사용이 가능하다. 클래스가 메모리에 로드될 때 생성된다. 메소드에 static이 붙는다면? 인스턴스를 생성하지 않고도 사용 가능한 클래스 메소드가 된다. 클래스 메소드 내에서는 인스턴스 멤버들을 사용할 수 없다. final - 마지막의, 변경될 수 없는 final이 사용될 수 있는 곳 : 클래스, 메소드, 멤버변수, 지역변수 클래스에 final이 붙는다면 확장될 수 없다. 즉 다른 클래스의 조상이 될수 없고 상속 구조에서 제일 마지막 클래스이다. 메…","fields":{"slug":"/java/java-modifier/"},"frontmatter":{"categories":"자바 자바의정석","title":"제어자","date":"June 13, 2023"}},"next":{"fields":{"slug":"/codingtest/codingtest-making-a-star/"}},"previous":{"fields":{"slug":"/codingtest/codingtest-snail/"}}},{"node":{"id":"09cb1bed-0ae4-5f1d-9d03-9e2536cccd59","excerpt":"상속 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것 상속을 받는다는 것은 상위 클래스를 확장(extends)한다는 의미로 해석된다. 하위 클래스는 상위클래스의 생성자, 초기화 블럭을 제외한 모든 멤버를 모두 상속받는다. 상위 클래스가 변경되면 모든 하위 클래스는 자동으로 영향을 받지만, 하위 클래스가 변경되는 것은 상위 클래스에 아무런 영향이 없다. 포함관계 상속 이외에도 클래스를 재사용하는 다른 방법, 한 클래스의 멤버변수로 다른 클래스 타입의 참조 변수를 선언하는 것 단일상속 자바에서는 단일 상속만 허용한다. Object 클래스 Object 클래스는 모든 클래스의 상위 클래스이다. 다른 클래스로부터 상속 받지 않는 모든 클래스들은 자동으로 Object 클래스를 상속받는다. 오버라이딩 상위 클래스로부터 상속받은 메소드의 내용을 변경하는 것, 상속받은 메소드를 그대로 사용하기도 하지만 필요에 따라 변경을 해야하는 경우 상위 클래스의 메소드를 오버라이딩 한다. 오버라이딩의 …","fields":{"slug":"/java/java-extends/"},"frontmatter":{"categories":"자바 자바의정석","title":"상속","date":"June 03, 2023"}},"next":{"fields":{"slug":"/java/java-constructor/"}},"previous":{"fields":{"slug":"/codingtest/codingtest-making-a-star/"}}},{"node":{"id":"c0a96f69-96b3-51a1-b40d-97e56b2dac17","excerpt":"인스턴스가 생성될 때 호출되는 인스턴스 초기화 메소드 생성자의 조건 생성자의 이름은 클래스 이름과 같아야 한다. 생성자는 리턴값이 없다 생성자의 정의 생성자도 오버로딩이 가능하므로 하나의 클래스의 여러개의 생성자가 존재할 수 있다.  연산자 new에 의해서 메모리에 Card 클래스의 인스턴스가 생성된다. 생성자 Card()가 호출되어 수행된다. 인스턴스를 생성할 때 반드시 클래스 내에 정의된 생성자 중 하나를 선택하여 지정해주어야 한다. 기본생성자 컴파일할 때 클래스에 생성자가 하나도 정의되어 있지 않은 경우 컴파일러는 자동으로 기본 생성자를 추가하여 컴파일한다. 컴파일러가 자동 추가해주는 기본생성자는 매개변수와 내용이 없다.  매개변수가 있는 생성자 매개변수가 있는 생성자를 사용한다면 인스턴스를 생성하는 동시에 원하는 값으로 초기화 할 수 있다. 생성자에서 다른 생성자 호출하기 조건 생성자의 이름으로 클래스이름 대신 this를 사용한다. 반드시 첫 줄에서만 호출이 가능하다. 기본…","fields":{"slug":"/java/java-constructor/"},"frontmatter":{"categories":"자바 자바의정석","title":"생성자","date":"May 29, 2023"}},"next":{"fields":{"slug":"/java/java-class-instance/"}},"previous":{"fields":{"slug":"/java/java-extends/"}}},{"node":{"id":"9aa2a387-ea08-53bc-a592-3727e30b3531","excerpt":"클래스 클래스란 객체를 정의해 놓은 것이며, 객체를 생성하는데 사용된다.\r\n클래스를 잘 만들어 놓으면 객체를 생성할 때마다 고민을 할 필요가 없으며, 만들어 놓은 클래스로부터 객체를 생성해서 사용하기만 하면 된다. 우리는 JDK에서 제공하는 클래스들을 이용해서 쉽게 프로그램을 작성할 수 있다. 클래스의 또 다른 정의 데이터와 함수의 결합\r\n함수와 데이터는 관계가 깊기 때문에 자바에서는 변수와 함수를 하나의 클래스에 정의하여 관계가 깊은 변수와 함수를 함께 다룰 수 있게했다. 사용자 정의 타입\r\n사용자 정의 타입은 사용자가 기능 동작을 위한 데이터와 함수를 묶어서 정의하는 것이다. 객체 객체는 클래스의 정의된 내용대로 메모리에 생성된 것이다.\r\n클래스로부터 객체를 만드는 것을 클래스의 인스턴스화라고 하며, 어떤 클래스로부터 만들어진 객체를 그 클래스의 인스턴스라고 한다.\r\n객체는 포괄적인 의미를 가지고 있다면, 인스턴스는 객체보다 구체적인 의미인 어떤 클래스로부터 만들어진 것인지를 …","fields":{"slug":"/java/java-class-instance/"},"frontmatter":{"categories":"자바 자바의정석","title":"클래스, 메소드, 변수, 인스턴스, 객체","date":"May 27, 2023"}},"next":{"fields":{"slug":"/java/java-recursive-call/"}},"previous":{"fields":{"slug":"/java/java-constructor/"}}},{"node":{"id":"cc3d75ca-df12-5da6-9dfe-1875ebae39fc","excerpt":"메소드 내부에서 메소드 자신을 다시 호출하는 것 어떻게 메소드가 자기 자신을 호출할 수 있는걸까? 메소드 입장에서는 자기 자신을 호출하는 것과 다른 메소드를 호출하는 것은 차이가 없다. ‘메소드 호출’ 이라는 것이 특정 위치에 저장되어 있는 명령들을 수행하는 것일 뿐이기 때문 호출된 메소드는 원래의 값이 아닌 복사된 값으로 작업하기 때문에 호출한 메소드와 관계없이 독립적인 작업 수행이 가능하다 :  재귀호출과 반복문 재귀호출은 반복문과 유사한 점이 많으며, 대부분의 재귀호출은 반복문으로 작성하는것이 가능하다.\r\n어떤 작업을 반복적으로 처리해야한다면, 먼저 반복문으로 작성해보고 너무 복잡하다면 재귀호출로 간단하게 할 수 없는지 고민해봐야한다.\r\n반복문보다 재귀호출이 비효율적이므로 재귀호출에 드는 비용보다 재귀호출의 간결함이 주는 이득이 충분히 큰 경우에만 사용해야한다. 대표적인 재귀호출 : 팩토리얼 팩토리얼은 한 숫자가 1이 될 때까지 1씩 감소시켜가면서 계속해서 곱해 나가는 것  …","fields":{"slug":"/java/java-recursive-call/"},"frontmatter":{"categories":"자바 자바의정석","title":"재귀호출","date":"May 27, 2023"}},"next":{"fields":{"slug":"/java/java-basic-reference-parameter/"}},"previous":{"fields":{"slug":"/java/java-class-instance/"}}},{"node":{"id":"804e5ba2-4c3d-5151-96b2-6b597ccd1c89","excerpt":"매개변수의 타입이 기본형일 때는 값이 복사되어서 변수의 값을 읽는 것만 가능하다.\r\n참조형일 때는 인스턴스의 주소가 복사되어서 변수의 값을 읽고 변경할 수 있다. 기본형 매개변수 호출한 메소드에 기본형 매개변수가 선언되어 있는 경우 인자(d.x)의 값을 복사하여 넘겨준 것 호출한 메소드에서 값을 1000으로 변경하더라도 호출한 메소드의 매개변수 값만 변경 될 뿐, 인자로 넘겨준 변수는 영향을 받지 않는다.\r\n 참조형 매개변수 호출된 메소드에 참조형 매개변수가 선언되어 있는 경우 값이 저장된 주소를 호출된 메소드에 넘겨준다. 호출된 메소드의 매개변수가 넘겨받은 인자와 같은 주소값을 가리키고 있기 때문에 호출된 메소드에서 값을 변경하게되면 그 주소값을 가지고 있는 변수의 값이 변경된다.\r\n 참조형 반환타입 copy메소드에서 생성한 객체를 main메소드에서 사용하려면 copy메소드 내에서 생성한 객체의 주소를 반환해주어야 한다. 그렇지 않으면 copy메소드가 종료되면서 생성한 객체의 참…","fields":{"slug":"/java/java-basic-reference-parameter/"},"frontmatter":{"categories":"자바 자바의정석","title":"기본형 매개변수와 참조형 매개변수 / 참조형 반환타입","date":"May 24, 2023"}},"next":null,"previous":{"fields":{"slug":"/java/java-recursive-call/"}}}]}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}